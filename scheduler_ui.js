<div><br class="Apple-interchange-newline">// ============================================================================<br>// scheduler_ui.js (UPDATED: TRANSITION WRAPPER & DISPLAY)<br>//<br>// Updates:<br>// 1. Implements Wrapper Block display logic for transitions (Issue 6).<br>// 2. Updated editCell to use new fillBlock logic for buffer-aware manual edits (Issue 15).<br>// ============================================================================<br><br>(function () {<br> "use strict";<br><br> const INCREMENT_MINS = 30; // Fallback only<br> const TRANSITION_TYPE = window.TRANSITION_TYPE; // "Transition/Buffer"<br><br> // ==========================================================================<br> // TIME HELPERS<br> // ==========================================================================<br> function parseTimeToMinutes(str) {<br> if (!str || typeof str !== "string") return null;<br> let s = str.trim().toLowerCase();<br> let mer = null;<br> if (s.endsWith("am") || s.endsWith("pm")) {<br> mer = s.endsWith("am") ? "am" : "pm";<br> s = s.replace(/am|pm/g, "").trim();<br> } else return null;<br> const m = s.match(/^(\d{1,2})\s*[:]\s*(\d{2})$/);<br> if (!m) return null;<br> let h = parseInt(m[1], 10);<br> const mm = parseInt(m[2], 10);<br> if (mm < 0 || mm > 59) return null;<br> if (h === 12) h = (mer === "am" ? 0 : 12);<br> else if (mer === "pm") h += 12;<br> return h * 60 + mm;<br> }<br><br> function minutesToTimeLabel(min) {<br> const h24 = Math.floor(min / 60);<br> const m = String(min % 60).padStart(2, "0");<br> const ap = h24 >= 12 ? "PM" : "AM";<br> const h12 = h24 % 12 || 12;<br> return `${h12}:${m} ${ap}`;<br> }<br><br> // ==========================================================================<br> // RESOURCE RESOLVER<br> // ==========================================================================<br> function resolveResourceName(input, knownNames) {<br> if (!input || !knownNames) return null;<br> const cleanInput = String(input).toLowerCase().trim();<br> <br> if (knownNames.includes(input)) return input;<br><br> const sortedNames = [...knownNames].sort((a,b) => b.length - a.length);<br> for (const name of sortedNames) {<br> const cleanName = name.toLowerCase().trim();<br> if (cleanInput.startsWith(cleanName)) {<br> return name;<br> }<br> }<br> return null; <br> }<br><br> // ==========================================================================<br> // DETECT GENERATED EVENTS<br> // ==========================================================================<br> const UI_GENERATED_EVENTS = new Set([<br> "general activity", "general activity slot", "activity", "activities", "sports", "sport", "sports slot", "special activity", "swim", "league game", "specialty league"<br> ]);<br> function uiIsGeneratedEventName(name) {<br> if (!name) return false;<br> return UI_GENERATED_EVENTS.has(String(name).trim().toLowerCase());<br> }<br><br> // ==========================================================================<br> // SLOT FINDER<br> // ==========================================================================<br> function findSlotsForRange(startMin, endMin) {<br> const slots = [];<br> const times = window.unifiedTimes || [];<br> if (!times.length) return slots;<br><br> for (let i = 0; i < times.length; i++) {<br> const slotStart = new Date(times[i].start).getHours() * 60 + new Date(times[i].start).getMinutes();<br> let slotEnd = new Date(times[i].end).getHours() * 60 + new Date(times[i].end).getMinutes();<br><br> if (startMin < slotEnd && endMin > slotStart) {<br> slots.push(i);<br> }<br> }<br> return slots;<br> }<br><br> // ==========================================================================<br> // EDIT CELL (BUFFER-AWARE MANUAL EDIT)<br> // ==========================================================================<br> function editCell(bunk, startMin, endMin, current) {<br> if (!bunk) return;<br> <br> // 1. Get user input<br> const newName = prompt(`Edit activity for ${bunk}\n${minutesToTimeLabel(startMin)} - ${minutesToTimeLabel(endMin)}\n(Enter CLEAR or FREE to empty)`, current);<br> if (newName === null) return; <br><br> const value = newName.trim();<br> const isClear = (value === "" || value.toUpperCase() === "CLEAR" || value.toUpperCase() === "FREE");<br> <br> // --- VALIDATION GATE ---<br> let resolvedName = value;<br> <br> if (!isClear && window.SchedulerCoreUtils && typeof window.SchedulerCoreUtils.loadAndFilterData === 'function') {<br> const warnings = [];<br> <br> // Load fresh data (This REBUILDS the Timeline with current grid state)<br> const config = window.SchedulerCoreUtils.loadAndFilterData();<br> const { activityProperties, historicalCounts, lastUsedDates, divisions } = config;<br> <br> const allKnown = Object.keys(activityProperties);<br> resolvedName = resolveResourceName(value, allKnown) || value; <br> const props = activityProperties[resolvedName]; <br> const targetSlots = findSlotsForRange(startMin, endMin);<br> <br> // -------------------------------------------------------------<br> // A. SAME BUNK CHECK (Duplicate Warning)<br> // -------------------------------------------------------------<br> const currentSchedule = window.scheduleAssignments[bunk] || [];<br> <br> currentSchedule.forEach((entry, idx) => {<br> if (targetSlots.includes(idx)) return; // Skip self<br> if (entry && !entry.continuation) {<br> const entryRaw = entry.field || entry._activity;<br> if (String(entryRaw).trim().toLowerCase() === String(value).trim().toLowerCase()) {<br> const timeLabel = window.unifiedTimes[idx]?.label || minutesToTimeLabel(new Date(window.unifiedTimes[idx].start).getHours() * 60 + new Date(window.unifiedTimes[idx].start).getMinutes());<br> warnings.push(`‚ö†Ô∏è DUPLICATE: ${bunk} is already scheduled for "${entryRaw}" at ${timeLabel}.`);<br> }<br> }<br> });<br><br> if (props) {<br> // -------------------------------------------------------------<br> // B. MAX USAGE CHECK (Frequency)<br> // -------------------------------------------------------------<br> const max = props.maxUsage || 0;<br> if (max > 0) {<br> const historyCount = historicalCounts[bunk]?.[resolvedName] || 0;<br> let todayCount = 0;<br> currentSchedule.forEach((entry, idx) => {<br> if (targetSlots.includes(idx)) return; <br> if (entry && !entry.continuation) {<br> const entryRes = resolveResourceName(entry.field || entry._activity, allKnown);<br> if (String(entryRes).toLowerCase() === String(resolvedName).toLowerCase()) todayCount++;<br> }<br> });<br> const total = historyCount + todayCount + 1; <br> if (total > max) {<br> const lastDateStr = lastUsedDates[bunk]?.[resolvedName];<br> const dateInfo = lastDateStr ? ` (Last used: ${lastDateStr})` : "";<br> warnings.push(`‚ö†Ô∏è MAX USAGE: ${bunk} has used "${resolvedName}" ${historyCount + todayCount} times${dateInfo}. Limit is ${max}.`);<br> }<br> }<br> <br> // -------------------------------------------------------------<br> // C. BUFFER DURATION CHECK (Issue 1)<br> // -------------------------------------------------------------<br> const transRules = window.SchedulerCoreUtils.getTransitionRules(resolvedName, activityProperties);<br> const { activityDuration } = window.SchedulerCoreUtils.getEffectiveTimeRange({startTime: startMin, endTime: endMin}, transRules);<br><br> if (activityDuration < transRules.minDurationMin) {<br> warnings.push(`‚ö†Ô∏è DURATION WARNING: Actual activity time is ${activityDuration} mins (Buffer: ${transRules.preMin + transRules.postMin} mins). Minimum required is ${transRules.minDurationMin} mins.`);<br> }<br><br> // -------------------------------------------------------------<br> // D. TIMELINE CAPACITY CHECK (The Gatekeeper)<br> // -------------------------------------------------------------<br> const tempBlock = { bunk, startTime: startMin, endTime: endMin, slots: targetSlots, divName: divisions[bunk]?.name };<br> const isAvailable = window.SchedulerCoreUtils.canBlockFit(<br> tempBlock, <br> resolvedName, <br> activityProperties, <br> window.fieldUsageBySlot,<br> resolvedName <br> );<br><br> if (!isAvailable) {<br> warnings.push(`‚ö†Ô∏è CAPACITY CONFLICT: "${resolvedName}" is blocked or full during this time.`);<br> }<br> <br> // -------------------------------------------------------------<br> // E. TIME RULES CHECK<br> // -------------------------------------------------------------<br> const isAvailableTime = targetSlots.every(slotIdx => window.SchedulerCoreUtils.isTimeAvailable(slotIdx, props));<br> if (!isAvailableTime) {<br> warnings.push(`‚ö†Ô∏è TIME RESTRICTION: "${resolvedName}" is closed/unavailable during this time block.`);<br> }<br> }<br><br> // F. BLOCKER PROMPT<br> if (warnings.length > 0) {<br> const msg = warnings.join("\n\n") + "\n\nDo you want to OVERRIDE these rules and schedule anyway?";<br> if (!confirm(msg)) {<br> return; <br> }<br> }<br> } <br><br> // --- APPLY EDIT (Use fillBlock for atomic buffer writing - Issue 15) ---<br> const slots = findSlotsForRange(startMin, endMin);<br> <br> if (!slots || slots.length === 0) {<br> alert("Error: Could not match this time range to the internal schedule grid. Please refresh the page.");<br> return;<br> }<br><br> if (!window.scheduleAssignments[bunk])<br> window.scheduleAssignments[bunk] = new Array(window.unifiedTimes.length);<br><br> if (isClear) {<br> // Manual clearance is always direct writes<br> slots.forEach((idx, i) => {<br> window.scheduleAssignments[bunk][idx] = {<br> field: "Free", sport: null, continuation: i > 0, _fixed: true, _activity: "Free"<br> };<br> });<br> } else {<br> // Fetch data for fillBlock<br> const config = window.SchedulerCoreUtils.loadAndFilterData();<br> const divName = Object.keys(config.divisions).find(d => config.divisions[d].bunks.includes(bunk));<br><br> // 1. Clear old data from this range first (important for re-writing)<br> slots.forEach(idx => window.scheduleAssignments[bunk][idx] = null);<br> <br> // 2. Use the central fillBlock logic to ensure buffers are generated correctly<br> window.fillBlock({<br> divName, bunk,<br> startTime: startMin, <br> endTime: endMin, <br> slots,<br> _fixed: true <br> }, {<br> field: resolvedName, <br> sport: null, <br> _fixed: true, <br> _activity: resolvedName<br> }, window.fieldUsageBySlot, config.yesterdayHistory, false, config.activityProperties);<br> }<br><br> saveSchedule();<br> updateTable();<br> }<br><br> function getEntry(bunk, slotIndex) {<br> const a = window.scheduleAssignments || {};<br> if (!a[bunk]) return null;<br> return a[bunk][slotIndex] || null;<br> }<br><br> // UPDATED: Format entry to check for transitions<br> function formatEntry(entry) {<br> if (!entry) return "";<br> if (entry._isDismissal) return "Dismissal";<br> if (entry._isSnack) return "Snacks";<br> <br> // Check if it's a Transition block<br> if (entry._isTransition) {<br> let label = entry.sport || entry.field;<br> // Use a clean label for the UI<br> return `üèÉ‚Äç‚ôÇÔ∏è ${label}`;<br> }<br><br> const label = entry._activity || entry.field || "";<br> if (entry._h2h) return entry.sport || "League Game";<br> if (entry._fixed) return label;<br> if (entry.sport) return `${entry.field} ‚Äì ${entry.sport}`;<br> return label;<br> }<br><br> function findFirstSlotForTime(startMin) {<br> if (!window.unifiedTimes) return -1;<br> for (let i = 0; i < window.unifiedTimes.length; i++) {<br> const slotStart = new Date(window.unifiedTimes[i].start).getHours() * 60 + new Date(window.unifiedTimes[i].start).getMinutes();<br> if (slotStart >= startMin && slotStart < startMin + INCREMENT_MINS) return i;<br> }<br> return -1;<br> }<br><br> function updateTable() {<br> const container = document.getElementById("scheduleTable");<br> if (!container) return;<br> renderStaggeredView(container);<br> }<br><br> // --- DYNAMIC GRID (UPDATED for Wrapper Block) ---<br> function renderStaggeredView(container) {<br> container.innerHTML = "";<br> const divisions = window.divisions || {};<br> const availableDivisions = window.availableDivisions || [];<br> const daily = window.loadCurrentDailyData?.() || {};<br> const manualSkeleton = daily.manualSkeleton || [];<br><br> if (!Array.isArray(manualSkeleton) || manualSkeleton.length === 0) {<br> container.innerHTML = `<p>No daily schedule generated for this date.</p>`;<br> return;<br> }<br><br> const wrapper = document.createElement("div");<br> wrapper.className = "schedule-view-wrapper";<br> container.appendChild(wrapper);<br><br> availableDivisions.forEach((div) => {<br> const bunks = (divisions[div]?.bunks || []).slice().sort();<br> if (bunks.length === 0) return;<br><br> const table = document.createElement("table");<br> table.className = "schedule-division-table";<br><br> const thead = document.createElement("thead");<br> const tr1 = document.createElement("tr");<br> const th = document.createElement("th");<br> th.colSpan = 1 + bunks.length;<br> th.textContent = div;<br> th.style.background = divisions[div]?.color || "#444";<br> th.style.color = "#fff";<br> tr1.appendChild(th);<br> thead.appendChild(tr1);<br><br> const tr2 = document.createElement("tr");<br> const thTime = document.createElement("th");<br> thTime.textContent = "Time";<br> tr2.appendChild(thTime);<br><br> bunks.forEach((b) => {<br> const thB = document.createElement("th");<br> thB.textContent = b;<br> tr2.appendChild(thB);<br> });<br><br> thead.appendChild(tr2);<br> table.appendChild(thead);<br><br> const tbody = document.createElement("tbody");<br><br> const blocks = manualSkeleton<br> .filter((b) => b.division === div)<br> .map((b) => ({<br> ...b,<br> startMin: parseTimeToMinutes(b.startTime),<br> endMin: parseTimeToMinutes(b.endTime),<br> }))<br> .filter((b) => b.startMin !== null && b.endMin !== null)<br> .sort((a, b) => a.startMin - b.startMin);<br><br> const expanded = [];<br> blocks.forEach((b) => {<br> if (b.type === "split") {<br> const mid = b.startMin + (b.endMin - b.startMin) / 2;<br> expanded.push({ ...b, endMin: mid, label: `${minutesToTimeLabel(b.startMin)} - ${minutesToTimeLabel(mid)}` });<br> expanded.push({ ...b, startMin: mid, label: `${minutesToTimeLabel(mid)} - ${minutesToTimeLabel(b.endMin)}` });<br> } else {<br> expanded.push({ ...b, label: `${minutesToTimeLabel(b.startMin)} - ${minutesToTimeLabel(b.endMin)}` });<br> }<br> });<br><br> expanded.forEach((block) => {<br> const tr = document.createElement("tr");<br> const tdTime = document.createElement("td");<br> tdTime.textContent = block.label;<br> tr.appendChild(tdTime);<br><br> const isLeague = block.event.startsWith("League Game") || block.event.startsWith("Specialty League");<br><br> if (isLeague) {<br> const td = document.createElement("td");<br> td.colSpan = bunks.length;<br> td.style.background = "#eef7f8";<br> td.style.fontWeight = "bold";<br><br> const slotIdx = findFirstSlotForTime(block.startMin);<br> let allMatchups = [];<br> let gameLabel = "";<br><br> if (slotIdx >= 0) {<br> const first = getEntry(bunks[0], slotIdx);<br> if (first) {<br> if(first._allMatchups) allMatchups = first._allMatchups;<br> if(first._gameLabel) gameLabel = first._gameLabel;<br> }<br> }<br><br> let titleHtml = block.event;<br> if (gameLabel) {<br> if (block.event.trim() === "League Game") {<br> titleHtml = `${block.event} ${gameLabel.replace(/^Game\s+/i, '')}`;<br> } else {<br> titleHtml = `${block.event} (${gameLabel})`;<br> }<br> }<br><br> if (allMatchups.length === 0) {<br> td.textContent = titleHtml;<br> } else {<br> td.innerHTML = `<div>${titleHtml}</div><ul>${allMatchups.map((m) => `<li>${m}</li>`).join("")}</ul>`;<br> }<br><br> td.style.cursor = "pointer";<br> td.onclick = () => editCell(bunks[0], block.startMin, block.endMin, block.event);<br><br> tr.appendChild(td);<br> tbody.appendChild(tr);<br> return;<br> }<br><br> // --- Standard & Generated Slots (New Wrapper Logic) ---<br> <br> bunks.forEach((bunk) => {<br> const td = document.createElement("td");<br> const slotIdx = findFirstSlotForTime(block.startMin);<br> const entry = getEntry(bunk, slotIdx);<br><br> const isDismissal = block.event.toLowerCase().includes("dismiss");<br> const isSnack = block.event.toLowerCase().includes("snack");<br> const isGeneratedSlot = uiIsGeneratedEventName(block.event) || block.event.includes("/");<br><br> let cellContent = "";<br> let finalActivity = "";<br> let isWrapperBlock = false;<br> let entryToDisplay = entry;<br><br> if (entry && entry._activity !== TRANSITION_TYPE) {<br> // This is the primary activity block (may be preceded/followed by transitions)<br> finalActivity = entry._activity;<br> <br> // Check if we are at the start of a wrapper sequence<br> const prevEntry = getEntry(bunk, slotIdx - 1);<br> const nextEntry = getEntry(bunk, slotIdx + 1);<br> <br> isWrapperBlock = (prevEntry?._activity === TRANSITION_TYPE || nextEntry?._activity === TRANSITION_TYPE);<br><br> if (isWrapperBlock) {<br> // Calculate the full wrapper time range<br> let totalPreTime = 0;<br> let totalPostTime = 0;<br> let activePlayTime = 0;<br> let startSlot = slotIdx;<br> let endSlot = slotIdx;<br><br> // Scan backward for Pre-Transition<br> let scanIdx = slotIdx - 1;<br> while(scanIdx >= 0 && getEntry(bunk, scanIdx)?._activity === TRANSITION_TYPE) {<br> totalPreTime += (new Date(window.unifiedTimes[scanIdx].end).getTime() - new Date(window.unifiedTimes[scanIdx].start).getTime()) / (1000 * 60);<br> startSlot = scanIdx;<br> scanIdx--;<br> }<br> <br> // Scan forward to find the end of the Activity + Post-Transition<br> scanIdx = slotIdx;<br> while(scanIdx < window.unifiedTimes.length) {<br> const currentScan = getEntry(bunk, scanIdx);<br> if (!currentScan || (currentScan._activity !== finalActivity && currentScan._activity !== TRANSITION_TYPE)) break;<br> <br> const slotDuration = (new Date(window.unifiedTimes[scanIdx].end).getTime() - new Date(window.unifiedTimes[scanIdx].start).getTime()) / (1000 * 60);<br><br> if (currentScan._activity === finalActivity) {<br> activePlayTime += slotDuration;<br> } else if (currentScan._activity === TRANSITION_TYPE) {<br> totalPostTime += slotDuration;<br> }<br> endSlot = scanIdx;<br> scanIdx++;<br> }<br> <br> // Only display content on the first slot of the entire merged block<br> if (slotIdx === startSlot) {<br> cellContent = `<strong>${finalActivity}</strong>`;<br> cellContent += `<br><span style="font-size:0.8em; color:#059669;">(${Math.round(totalPreTime)}m To / ${Math.round(activePlayTime)}m Play / ${Math.round(totalPostTime)}m From)</span>`;<br> td.rowSpan = endSlot - startSlot + 1;<br> td.style.verticalAlign = 'top';<br> td.style.textAlign = 'center';<br> td.style.background = '#e0f7fa';<br> <br> // Mark this cell as having content drawn<br> td.dataset.drawn = 'true';<br> td.dataset.endSlot = endSlot;<br><br> } else {<br> // This is a continuation of a wrapper block, suppress it<br> td.style.display = 'none';<br> }<br><br> } else {<br> // Standard entry (not part of a wrapper)<br> cellContent = formatEntry(entry);<br> }<br><br><br> } else if (entry && entry._activity === TRANSITION_TYPE) {<br> // If this is a transition block, suppress content if it's part of a larger sequence.<br> // We rely on the activity block (above) to draw the merged span.<br> <br> // Check if the content was drawn by a previous cell in the same block time<br> let scanIdx = slotIdx;<br> let isContinuation = false;<br> while(scanIdx >= 0) {<br> const prevScan = getEntry(bunk, scanIdx);<br> if (prevScan && prevScan._activity !== TRANSITION_TYPE && (prevScan._activity === getEntry(bunk, slotIdx+1)?._activity)) {<br> isContinuation = true;<br> break;<br> }<br> scanIdx--;<br> }<br><br> if (getEntry(bunk, slotIdx - 1)?.field === getEntry(bunk, slotIdx)?.field || isContinuation) {<br> td.style.display = 'none';<br> } else {<br> // Fallback for isolated transition blocks (rare, but possible)<br> cellContent = formatEntry(entry);<br> }<br> <br> } else {<br> // Dismissal/Snack/Free/Unassigned<br> if (isDismissal) {<br> cellContent = "Dismissal";<br> bg = "#ffdddd";<br> } else if (isSnack) {<br> cellContent = "Snacks";<br> bg = "#e7ffe7";<br> } else if (!isGeneratedSlot) {<br> bg = "#fff7cc";<br> cellContent = block.event;<br> } else {<br> cellContent = formatEntry(entry);<br> }<br> }<br> <br> // Fallback content if wrapper logic failed to provide it<br> if (cellContent === "" && td.style.display !== 'none') {<br> // Check if the previous cell created a span that covers this one<br> const prevTd = tr.previousElementSibling?.querySelector(`[data-bunk="${bunk}"][data-end-slot]`);<br> if (prevTd && parseInt(prevTd.dataset.endSlot) >= slotIdx) {<br> td.style.display = 'none';<br> }<br> }<br><br><br> td.textContent = cellContent;<br> td.style.cursor = "pointer";<br> td.onclick = () => editCell(bunk, block.startMin, block.endMin, finalActivity || cellContent);<br> <br> tr.appendChild(td);<br> });<br> tbody.appendChild(tr);<br> });<br> table.appendChild(tbody);<br> wrapper.appendChild(table);<br> });<br> }<br><br> function saveSchedule() {<br> window.saveCurrentDailyData?.("scheduleAssignments", window.scheduleAssignments);<br> window.saveCurrentDailyData?.("leagueAssignments", window.leagueAssignments);<br> window.saveCurrentDailyData?.("unifiedTimes", window.unifiedTimes);<br> }<br><br> function reconcileOrRenderSaved() {<br> try {<br> const data = window.loadCurrentDailyData?.() || {};<br> window.scheduleAssignments = data.scheduleAssignments || {};<br> window.leagueAssignments = data.leagueAssignments || {};<br> const savedTimes = data.unifiedTimes || [];<br> window.unifiedTimes = savedTimes.map((slot) => ({ ...slot, start: new Date(slot.start), end: new Date(slot.end) }));<br> } catch (e) {<br> console.error("Schedule load error:", e);<br> window.scheduleAssignments = {};<br> window.leagueAssignments = {};<br> window.unifiedTimes = [];<br> }<br> updateTable();<br> }<br><br> function initScheduleSystem() { reconcileOrRenderSaved(); }<br><br> window.updateTable = updateTable;<br> window.initScheduleSystem = initScheduleSystem;<br> window.saveSchedule = saveSchedule;<br>})();</div>
